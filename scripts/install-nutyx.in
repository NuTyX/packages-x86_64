#***********************************************************************
# Written by Thierry Nuttens
# Copyright Thierry Nuttens 2010 - 2021
# Installation script for the NuTyX system
# Based on LFS scripts
#***********************************************************************

#***********************************************************************
# Function - boot_mesg()
#
# Purpose:      Sending information from bootup scripts to the console
#
# Inputs:       $1 is the message
#               $2 is the colorcode for the console
#
# Outputs:      Standard Output
#
# Dependencies: - sed for parsing strings.
#               - grep for counting string length.
#
# Todo:
#***********************************************************************
boot_mesg() {
	local ECHOPARM=""

	while true
	do
		case "${1}" in
			-n)
				ECHOPARM=" -n "
				shift 1
				;;
			-*)
				echo "Unknown Option: ${1}"
				return 1
				;;
			*)
				break
				;;
		esac
	done

	## Figure out the length of what is to be printed to be used
	## for warning messages.
	STRING_LENGTH=$((${#1} + 1))

	# Print the message to the screen
	${ECHO} ${ECHOPARM} -e "${2}${1}"
}
boot_mesg_flush() {
	# Reset STRING_LENGTH for next message
	STRING_LENGTH="0"
}
echo_ok() {
	${ECHO} -n -e "${CURS_UP}${SET_COL}${BRACKET}[${SUCCESS}  OK  ${BRACKET}]"
	${ECHO} -e "${NORMAL}"
	boot_mesg_flush
}
echo_info() {
	${ECHO} -n -e "${CURS_UP}${SET_COL}${BRACKET}[${INFO} INFO ${BRACKET}]"
	${ECHO} -e "${NORMAL}"
	boot_mesg_flush
}
echo_failure() {
	${ECHO} -n -e "${CURS_UP}${SET_COL}${BRACKET}[${FAILURE} FAIL ${BRACKET}]"
	${ECHO} -e "${NORMAL}"
	boot_mesg_flush
}
print_error_msg() {
	echo_failure
	ERREUR="yes"
	# $i is inherited by the rc script
	boot_mesg -n " FAILURE:\n\n You should not read this error.\n\n" ${FAILURE}
	boot_mesg -n " It means something went wrong with the installation"
	boot_mesg -n " of ${i} "
	boot_mesg_flush
	boot_mesg -n " Thanks to inform us"
	boot_mesg -n " via the website http://www.nutyx.org."
	boot_mesg " Thanks again for your collaboration.\n"
	boot_mesg_flush
	boot_mesg -n "Press Enter to continue..." ${INFO}
	boot_mesg "" ${NORMAL}
	read ENTER
	end
	exit 1
}
#***********************************************************************
# Function - unmountall
#
# Purpose:	unmount all the mounted disks and partitions
#
# Inputs:	$1 the full path of the Distro
#
# Outputs:	Standard Output
#
# Dependencies: chroot
#
#***********************************************************************
unmountall() {
if [ -d "$DEPOT_CD/depot" ]; then
	umount ${LFS}/${DEPOT}
	umount  $(cat /tmp/depot)
fi
[ ! -z $MOUNT ] && umount ${LFS}/${DEPOT}

umount ${LFS}/run
umount ${LFS}/dev/pts
umount ${LFS}/dev
umount ${LFS}/proc
umount ${LFS}/sys
}
#***********************************************************************
# Function - setup_chroot
#
# Purpose:	Enter the NuTyX Distribution
#
# Inputs:	$1 the full path of the Distro
#
# Outputs:	Standard Output
#
# Dependencies: chroot
#
#***********************************************************************
setup_chroot() {
cp /etc/resolv.conf ${LFS}/etc/resolv.conf
mount --bind /dev ${LFS}/dev
mount -t devpts devpts ${LFS}/dev/pts
mount -t proc proc ${LFS}/proc
mount -t sysfs sysfs ${LFS}/sys
mount -t tmpfs tmpfs ${LFS}/run
if [ -h ${LFS}/dev/shm ]; then
   mkdir -p ${LFS}/$(readlink ${LFS}/dev/shm)
fi
if [ ! -L ${LFS}/bin/sh ];then
  ln -sv ../sbin/busybox ${LFS}/bin/bash
  ln -sv bash ${LFS}/bin/sh
fi
}
enter_chroot() {
echo "
******************************
Chroot path: $LFS
******************************"
chroot ${LFS} env -i \
HOME=/root \
EUID=0 \
TERM="$TERM" \
PS1='\u:\w\$ ' \
$LINUX_ARCH \
$SHELL -l
}
#***********************************************************************
# Function - download_pkg()
#
# Purpose:      Download the selected package
#
# Inputs:       $1 is the package
#
# Dependencies: - curl
#
# Todo:
#***********************************************************************
download_pkg() {
	getPackageFileName ${1}
	if [ ! -f $LFS/$DEPOT/${BASE_COLLECTION}/${1}/$PackageFileName ]; then
		boot_mesg "Downloading $1..."
		echo_info
		curl -LC - -# --create-dirs \
		${DEPOT_BASE}/${1}/$PackageFileName \
		-o $LFS/$DEPOT/${BASE_COLLECTION}/${1}/$PackageFileName || \
			error "Cannot download ${DEPOT_BASE}/${1}/$PackageFileName ..., check URL"
		chmod -R 755 $LFS/$DEPOT
		echo_ok
	fi
}
#***********************************************************************
# Function - install_pkg()
#
# Purpose     : Install the selected package
#
# Inputs      : $1 is the package
#               $2 is the group
#		        $3 Option to install, normally nothing except for grub
# Outputs     : Standard Output
#
# Dependencies: boot_mesg
#               pkgadd
#***********************************************************************
install_pkg() {
	getPackageFileName ${1}
	if $TMP/$(dirname $PKGADD)/pkginfo -r $LFS -i| grep "^$1 " \
		> /dev/null; then
		boot_mesg "$1 is already install on $LFS..."
		echo_info
	fi
	if [ -f $LFS/$DEPOT/${BASE_COLLECTION}/${1}/$PackageFileName ]; then
		# Installing the package
		$TMP/$PKGADD -r $LFS -i \
		$LFS/$DEPOT/${BASE_COLLECTION}/${1}/$PackageFileName \
			|| print_error_msg
		rm -f $LFS/.{PRE,POST,README}
		echo_ok
	else
		error "$PackageFileName not found"
	fi
}
error() {
	echo "
 $1
"
	ERREUR="yes"
	end
	exit 1
}
end() {
	if [ "$ERREUR" == "yes" ]; then
		if [ ! -f $TMP/depot ]; then
			umount ${LFS}/${DEPOT} || rm -r ${LFS}/${DEPOT}
			boot_mesg "Cleaning up temporary files.."
			boot_mesg "Please correct and start again"
		fi
	fi
	cd ~
	unmountall $LFS > /dev/null 2>&1

	rm -rf $TMP
}
#***********************************************************************
# Function getPackageFileName
#
# Purpose:	Get the fullname of the package
#		directory
# Inputs:	$1 is the package name
#
# Dependencies: - curl
#
# Output:       PackageFileName= cpio1414074943i686.cards.tar.xz
#
#***********************************************************************
getPackageFileName() {
	local BUILD_DATE EXT HEAD
	if [ ! -f $LFS/$DEPOT/${BASE_COLLECTION}/${1}/.PKGREPO ]; then
		curl -LC - -sS --create-dirs \
		${DEPOT_BASE}/${1}/.PKGREPO -o \
		$LFS/$DEPOT/${BASE_COLLECTION}/${1}/.PKGREPO || \
		error "Cannot download ${DEPOT_BASE}/${1}/.PKGREPO ..., check URL"
		chmod -R 755 $LFS/$DEPOT
	fi
	if [ $(wc -l $LFS/$DEPOT/${BASE_COLLECTION}/${1}/.PKGREPO|cut -d " " -f1) -eq 0 ]; then
		error "${DEPOT_BASE}/${1} not reacheable.."
	fi
	HEAD=$(head -1 $LFS/$DEPOT/${BASE_COLLECTION}/${1}/.PKGREPO)
	if [ "${HEAD:10:1}" == "#" ]; then
		BUILD_DATE="$(echo $HEAD|cut -d "#" -f1)"
		EXT="$(echo $HEAD|cut -d "#" -f2)"
		PackageFileName="${1}${BUILD_DATE}${ARCH}${EXT}"
	fi
}
install_chroot() {
for i in $CHROOT
do
	download_pkg "$i"
done
for i in $CHROOT
do
	install_pkg "$i"
done
}
generate_etc_bashrc() {
local FILE
FILE="bashrc"
[ -f ${LFS}/etc/$FILE ] && return
[ ! -d ${LFS}/etc ] && mkdir -pv ${LFS}/etc
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
  ${LFS}/etc/$FILE
  return
fi
cat > ${LFS}/etc/$FILE << "EOF"
# Begin /etc/bashrc
# Written for Beyond Linux From Scratch
# by James Robertson <jameswrobertson@earthlink.net>
# updated by Bruce Dubbs <bdubbs@linuxfromscratch.org>

# System wide aliases and functions.

# System wide environment variables and startup programs should go into
# /etc/profile.  Personal environment variables and startup programs
# should go into ~/.bash_profile.  Personal aliases and functions should
# go into ~/.bashrc

# Provides a colored /bin/ls command.  Used in conjunction with code in
# /etc/profile.

alias ls='ls --color=auto'

# Provides prompt for non-login shells, specifically shells started
# in the X environment. [Review the LFS archive thread titled
# PS1 Environment Variable for a great case study behind this script
# addendum.]

NORMAL="\[\e[0m\]"
RED="\[\e[1;31m\]"
GREEN="\[\e[1;32m\]"
WHITE="\[\e[1;37m\]"
INFOMACHINE="$(date +%H:%M) $(uname -m) $(uname -r) $(whoami)@$(uname -n)"
prompt_command() {
# Sauvegarde de la pos courante
tput sc
# Calcul de la largeur
let backwash=$(tput cols)-$(echo $INFOMACHINE | wc -m)-2
# Pos des curseurs à la position Y=0, X=longueur calculée
tput cup 0 ${backwash}
# Spécifie la couleur et la casse de la police
tput setaf 4; tput bold
# Affiche le chemin entre crochets
echo -n "["
# Specifie la couleur du chemin
tput setaf 6
# Affiche le chemin complet
echo -n "$INFOMACHINE"
tput setaf 4; tput bold
# Affiche le crochet fermé
echo -n "]"
# Remet le curseur à sa place
tput rc
}
PROMPT_COMMAND=prompt_command

case $TERM in
        xterm|rxvt*)
                TITLEBAR='\[\033]0;\u@\h \007\]'
                ;;
        *)
                TITLEBAR=''
                ;;
esac

if [[ $EUID == 0 ]] ; then
  PS1="$TITLEBAR$RED\u [ $NORMAL\w$RED ]# $NORMAL"
else
  PS1="$TITLEBAR$GREEN\u [ $NORMAL\w$GREEN ]\$ $NORMAL"
fi
# End /etc/bashrc
EOF
}
generate_rc_site() {
local FILE
FILE="rc.site"
[ -f ${LFS}/etc/sysconfig/$FILE ] && return
[ ! -d ${LFS}/etc/sysconfig ] && mkdir -pv ${LFS}/etc/sysconfig
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
  ${LFS}/etc/sysconfig/$FILE
  return
fi
cat > ${LFS}/etc/sysconfig/$FILE << "EOF"
# rc.site
# Optional parameters for boot scripts.

# Distro Information
# These values, if specified here, override the defaults
#DISTRO="Linux From Scratch" # The distro name
#DISTRO_CONTACT="lfs-dev@linuxfromscratch.org" # Bug report address
#DISTRO_MINI="LFS" # Short name used in filenames for distro config

# Define custom colors used in messages printed to the screen

# Please consult `man console_codes` for more information
# under the "ECMA-48 Set Graphics Rendition" section
#
# Warning: when switching from a 8bit to a 9bit font,
# the linux console will reinterpret the bold (1;) to
# the top 256 glyphs of the 9bit font.  This does
# not affect framebuffer consoles

# These values, if specified here, override the defaults
#BRACKET="\\033[1;34m" # Blue
#FAILURE="\\033[1;31m" # Red
#INFO="\\033[1;36m"    # Cyan
#NORMAL="\\033[0;39m"  # Grey
#SUCCESS="\\033[1;32m" # Green
#WARNING="\\033[1;33m" # Yellow

# Use a colored prefix
# These values, if specified here, override the defaults
#BMPREFIX="     "
#SUCCESS_PREFIX="${SUCCESS}  *  ${NORMAL}"
#FAILURE_PREFIX="${FAILURE}*****${NORMAL}"
#WARNING_PREFIX="${WARNING} *** ${NORMAL}"

# Interactive startup
#IPROMPT="yes" # Whether to display the interactive boot prompt
#itime="3"    # The amount of time (in seconds) to display the prompt

# The total length of the distro welcome string, without escape codes
#wlen=$(echo "Welcome to ${DISTRO}" | wc -c )
#welcome_message="Welcome to ${INFO}${DISTRO}${NORMAL}"

# The total length of the interactive string, without escape codes
#ilen=$(echo "Press 'I' to enter interactive startup" | wc -c )
#i_message="Press '${FAILURE}I${NORMAL}' to enter interactive startup"

# Set scripts to skip the file system check on reboot
#FASTBOOT=yes

# Skip reading from the console
#HEADLESS=yes

# Write out fsck progress if yes
#VERBOSE_FSCK=no

# Speed up boot without waiting for settle in udev
#OMIT_UDEV_SETTLE=y

# Speed up boot without waiting for settle in udev_retry
#OMIT_UDEV_RETRY_SETTLE=yes

# Skip cleaning /tmp if yes
#SKIPTMPCLEAN=no

# For setclock
#UTC=1
#CLOCKPARAMS=

# For consolelog
#LOGLEVEL=5

# For network
#HOSTNAME=mylfs

# Delay between TERM and KILL signals at shutdown
#KILLDELAY=3

# Optional sysklogd parameters
#SYSKLOGD_PARMS="-m 0"

# Console parameters
#UNICODE=1
#KEYMAP="de-latin1"
#KEYMAP_CORRECTIONS="euro2"
#FONT="lat0-16 -m 8859-15"
#LEGACY_CHARSET=
EOF
}
generate_udev_retry() {
local FILE
FILE="udev_retry"
[ -f ${LFS}/etc/sysconfig/$FILE ] && return
[ ! -d ${LFS}/etc/sysconfig ] && mkdir -pv ${LFS}/etc/sysconfig
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/sysconfig/$FILE \
   ${LFS}/etc/sysconfig/$FILE
   return
fi
cat > ${LFS}/etc/sysconfig/$FILE << "EOF"
########################################################################
# Begin /etc/sysconfig/udev_retry
#
# Description : udev_retry script configuration
#
# Authors     :
#
# Version     : 00.00
#
#
#	Each subsystem that may need to be re-triggered after mountfs
#	runs should be listed in this file.  Probable subsystems to be
#	listed here are rtc (due to /var/lib/hwclock/adjtime) and sound
#	(due to both /var/lib/alsa/asound.state and /usr/sbin/alsactl).
#	Entries are whitespace-separated.
########################################################################

rtc

# End /etc/sysconfig/udev_retry
EOF
}
generate_xdm() {
local FILE
FILE="xdm"
[ -f ${LFS}/etc/sysconfig/$FILE ] && return
[ ! -d ${LFS}/etc/sysconfig ] && mkdir -pv ${LFS}/etc/sysconfig
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/sysconfig/$FILE \
   ${LFS}/etc/sysconfig/$FILE
   return
fi
cat > ${LFS}/etc/sysconfig/$FILE << "EOF"
# Which display manager to use (full path):
# DISPLAY_MANAGER=/usr/sbin/lxdm
# DISPLAY_MANAGER=/usr/sbin/xdm
# DISPLAY_MANAGER="/usr/bin/slim -d"
# DISPLAY_MANAGER=/usr/bin/lightdm
# DISPLAY_MANAGER=/usr/sbin/gdm
# DISPLAY_MANAGER=/usr/bin/sddm

# Options to pass to the display manager:
DM_OPTIONS=""
EOF
}
generate_createfiles() {
local FILE
FILE="createfiles"
[ -f ${LFS}/etc/sysconfig/$FILE ] && return
[ ! -d ${LFS}/etc/sysconfig ] && mkdir -pv ${LFS}/etc/sysconfig
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
   ${LFS}/etc/sysconfig/$FILE
   return
fi
cat > ${LFS}/etc/sysconfig/$FILE << "EOF"
########################################################################
# Begin /etc/sysconfig/createfiles
#
# Description : Createfiles script config file
#
# Authors     :
#
# Version     : 00.00
#
# Notes       : The syntax of this file is as follows:
# 		if type is equal to "file" or "dir"
#  		<filename> <type> <permissions> <user> <group>
# 		if type is equal to "dev"
#  		<filename> <type> <permissions> <user> <group> <devtype>
#             <major> <minor>
#
# 		<filename> is the name of the file which is to be created
# 		<type> is either file, dir, or dev.
#   			file creates a new file
#   			dir creates a new directory
#   			dev creates a new device
# 		<devtype> is either block, char or pipe
#   			block creates a block device
#   			char creates a character deivce
#   			pipe creates a pipe, this will ignore the <major> and
#           <minor> fields
# 		<major> and <minor> are the major and minor numbers used for
#     the device.
########################################################################

# End /etc/sysconfig/createfiles
EOF
}
generate_modules() {
local FILE
FILE="modules"
[ -f ${LFS}/etc/sysconfig/$FILE ] && return
[ ! -d ${LFS}/etc/sysconfig ] && mkdir -pv ${LFS}/etc/sysconfig
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
   ${LFS}/etc/sysconfig/$FILE
   return
fi
cat > ${LFS}/etc/sysconfig/$FILE << "EOF"
########################################################################
# Begin /etc/sysconfig/modules
#
# Description : Module auto-loading configuration
#
# Authors     :
#
# Version     : 00.00
#
# Notes       : The syntax of this file is as follows:
#  		<module> [<arg1> <arg2> ...]
#
# Each module should be on its own line, and any options that you want
# passed to the module should follow it.  The line deliminator is either
# a space or a tab.
########################################################################

# End /etc/sysconfig/modules
EOF
}
generate_mouse() {
local FILE
FILE="mouse"
[ -f ${LFS}/etc/$FILE ] && return
[ ! -d ${LFS}/etc/sysconfig ] && mkdir -pv ${LFS}/etc/sysconfig
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
   ${LFS}/etc/sysconfig/$FILE
   return
fi
cat > ${LFS}/etc/sysconfig/$FILE << "EOF"
MDEVICE="/dev/input/mice"
PROTOCOL="imps2"
EOF
}
generate_inputrc() {
local FILE
FILE="inputrc"
[ -f ${LFS}/etc/$FILE ] && return
[ ! -d ${LFS}/etc ] && mkdir -pv ${LFS}/etc
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
   ${LFS}/etc/$FILE
   return
fi
cat > ${LFS}/etc/$FILE << "EOF"
# Begin /etc/inputrc
# Modified by Chris Lynn <roryo@roryo.dynup.net>

# Allow the command prompt to wrap to the next line
set horizontal-scroll-mode Off

# Enable 8bit input
set meta-flag On
set input-meta On

# Turns off 8th bit stripping
set convert-meta Off

# Keep the 8th bit for display
set output-meta On

# none, visible or audible
set bell-style none

# All of the following map the escape sequence of the value
# contained in the 1st argument to the readline specific functions
"\eOd": backward-word
"\eOc": forward-word

# for linux console
"\e[1~": beginning-of-line
"\e[4~": end-of-line
"\e[5~": beginning-of-history
"\e[6~": end-of-history
"\e[3~": delete-char
"\e[2~": quoted-insert

# for xorg-term
"\eOH": beginning-of-line
"\eOF": end-of-line

# for Konsole
"\e[H": beginning-of-line
"\e[F": end-of-line

# End /etc/inputrc
EOF
}
generate_hosts() {
local FILE
FILE="hosts"
[ -f ${LFS}/etc/$FILE ] && return
[ ! -d ${LFS}/etc ] && mkdir -pv ${LFS}/etc
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
  cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
  ${LFS}/etc/$FILE
  return
fi
cat > ${LFS}/etc/$FILE << "EOF"
127.0.0.1 localhost.localdomain localhost
EOF
}
generate_shells() {
local FILE
FILE="shells"
[ -f ${LFS}/etc/$FILE ] && return
[ ! -d ${LFS}/etc ] && mkdir -pv ${LFS}/etc
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
  cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
  ${LFS}/etc/$FILE
  return
fi
cat > ${LFS}/etc/$FILE << "EOF"
# Begin /etc/shells
/bin/sh
/bin/bash
EOF
}
generate_umask_sh() {
local FILE
FILE="umask.sh"
[ -f ${LFS}/etc/profile.d/$FILE ] && return
[ ! -d ${LFS}/etc/profile.d ] && mkdir -pv ${LFS}/etc/profile.d
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
   ${LFS}/etc/profile.d/$FILE
   return
fi
cat > ${LFS}/etc/profile.d/$FILE << "EOF"
# By default we want the umask to get set.
if [ "$(id -gn)" = "$(id -un)" -a $EUID -gt 99 ] ; then
  umask 002
else
  umask 022
fi
EOF
}
generate_readline_sh() {
local FILE
FILE="readline.sh"
[ -f ${LFS}/etc/profile.d/$FILE ] && return
[ ! -d ${LFS}/etc/profile.d ] && mkdir -pv ${LFS}/etc/profile.d
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
   ${LFS}/etc/profile.d/$FILE
   return
fi
cat > ${LFS}/etc/profile.d/$FILE << "EOF"
# Setup the INPUTRC environment variable.
if [ -z "$INPUTRC" -a ! -f "$HOME/.inputrc" ] ; then
        INPUTRC=/etc/inputrc
fi
export INPUTRC
EOF
}
generate_extrapaths_sh() {
local FILE
FILE="extrapaths.sh"
[ -f ${LFS}/etc/profile.d/$FILE ] && return
[ ! -d ${LFS}/etc/profile.d ] && mkdir -pv ${LFS}/etc/profile.d
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
   ${LFS}/etc/profile.d/$FILE
   return
fi
cat > ${LFS}/etc/profile.d/$FILE << "EOF"
if [ -d /usr/local/lib/pkgconfig ] ; then
        pathappend /usr/local/lib/pkgconfig PKG_CONFIG_PATH
fi
if [ -d /usr/local/bin ]; then
        pathprepend /usr/local/bin
fi
if [ -d /usr/local/sbin -a $EUID -eq 0 ]; then
        pathprepend /usr/local/sbin
fi

if [ -d ~/bin ]; then
        pathprepend ~/bin
fi
#if [ $EUID -gt 99 ]; then
#        pathappend .
#fi
EOF
}
generate_dircolors_sh() {
local FILE
FILE="dircolors.sh"
[ -f ${LFS}/etc/profile.d/$FILE ] && return
[ ! -d ${LFS}/etc/profile.d ] && mkdir -pv ${LFS}/etc/profile.d
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
   ${LFS}/etc/profile.d/$FILE
   return
fi
cat > ${LFS}/etc/profile.d/$FILE << "EOF"
# Setup for /bin/ls to support color, the alias is in /etc/bashrc.
if [ -f "/etc/dircolors" ] ; then
        eval $(dircolors -b /etc/dircolors)

        if [ -f "$HOME/.dircolors" ] ; then
                eval $(dircolors -b $HOME/.dircolors)
        fi
fi
alias ls='ls --color=auto'
EOF
}
generate_profile() {
local FILE
FILE="profile"
[ -f ${LFS}/etc/$FILE ] && return
[ ! -d ${LFS}/etc ] && mkdir -pv ${LFS}/etc
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
   ${LFS}/etc/$FILE
   return
fi
cat > ${LFS}/etc/$FILE << "EOF"
# Begin /etc/profile
# Written for Beyond Linux From Scratch
# by James Robertson <jameswrobertson@earthlink.net>
# modifications by Dagmar d'Surreal <rivyqntzne@pbzpnfg.arg>

# System wide environment variables and startup programs.

# System wide aliases and functions should go in /etc/bashrc.  Personal
# environment variables and startup programs should go into
# ~/.bash_profile.  Personal aliases and functions should go into
# ~/.bashrc.

# Functions to help us manage paths.  Second argument is the name of the
# path variable to be modified (default: PATH)
pathremove () {
        local IFS=':'
        local NEWPATH
        local DIR
        local PATHVARIABLE=${2:-PATH}
        for DIR in ${!PATHVARIABLE} ; do
                if [ "$DIR" != "$1" ] ; then
                  NEWPATH=${NEWPATH:+$NEWPATH:}$DIR
                fi
        done
        export $PATHVARIABLE="$NEWPATH"
}

pathprepend () {
        pathremove $1 $2
        local PATHVARIABLE=${2:-PATH}
        export $PATHVARIABLE="$1${!PATHVARIABLE:+:${!PATHVARIABLE}}"
}

pathappend () {
        pathremove $1 $2
        local PATHVARIABLE=${2:-PATH}
        export $PATHVARIABLE="${!PATHVARIABLE:+${!PATHVARIABLE}:}$1"
}

[ "$SHELL" == "/bin/bash" ] &&  export -f pathremove pathprepend pathappend

# Set the initial path
export PATH=/usr/bin:/bin:/usr/sbin:/sbin

if [ $EUID -eq 0 ] ; then
        unset HISTFILE
fi

# Setup some environment variables.
export HISTSIZE=1000
export HISTIGNORE="&:[bf]g:exit"

# Set some defaults for graphical systems
export XDG_DATA_DIRS=${XDG_DATA_DIRS:-/usr/share}
export XDG_CONFIG_DIRS=${XDG_CONFIG_DIRS:-/etc/xdg}
export XDG_RUNTIME_DIR=${XDG_RUNTIME_DIR:-/tmp/xdg-$USER}

# Setup a red prompt for root and a green one for users.
NORMAL="\[\e[0m\]"
RED="\[\e[1;31m\]"
GREEN="\[\e[1;32m\]"
if [[ $EUID == 0 ]] ; then
  PS1="$RED\u [ $NORMAL\w$RED ]# $NORMAL"
else
  PS1="$GREEN\u [ $NORMAL\w$GREEN ]\$ $NORMAL"
fi

for script in /etc/profile.d/*.sh ; do
        if [ -r $script ] ; then
                . $script
        fi
done

unset script RED GREEN NORMAL

# End /etc/profile
EOF
}
generate_group() {
local FILE
FILE="group"
[ -f ${LFS}/etc/$FILE ] && return
[ ! -d ${LFS}/etc ] && mkdir -pv ${LFS}/etc
cat > ${LFS}/etc/$FILE << "EOF"
root:x:0:
bin:x:1:daemon
sys:x:2:
kmem:x:3:
tape:x:4:
tty:x:5:
daemon:x:6:
floppy:x:7:
disk:x:8:
lp:x:9:
dialout:x:10:
audio:x:11
video:x:12
utmp:x:13:
usb:x:14:
cdrom:x:15:
adm:x:16:
atd:x:17:
messagebus:x:18:
input:x:24:
man:x:29
wheel:x:30:root
games:x:60:
scanner:x:70:
vboxusers:x:80:
netdev:x:86:
unbound:x:88:
nogroup:x:99:
users:x:999:
EOF
}
generate_passwd() {
local FILE
FILE="passwd"
[ -f ${LFS}/etc/$FILE ] && return
[ ! -d ${LFS}/etc ] && mkdir -pv ${LFS}/etc
cat > ${LFS}/etc/$FILE << "EOF"
root::0:0:root:/root:/bin/bash
bin:x:1:1:bin:/dev/null:/bin/false
daemon:x:6:6:Daemon User:/dev/null:/bin/false
lp:x:9:9:Print Service User:/dev/null:/bin/false
atd:x:17:17:add daemon:/dev/null:/bin/false
messagebus:x:18:18:D-Bus Message Daemon User:/dev/null:/bin/false
man:x:29:29:Man Pages:/dev/null:/bin/false
games:x:60:60:Games High Score Owner:/var/games:/bin/false
unbound:x:88:88:Unbound DNS resolver:/var/lib/unbound:/bin/false
anonymous:x:98:99:Unprivileged User:/dev/null:/bin/false
nobody:x:99:99:Unprivileged User:/dev/null:/bin/false
EOF
}
generate_fstab() {
local FILE
FILE="fstab"
[ -f ${LFS}/etc/$FILE ] && return
[ ! -d ${LFS}/etc ] && mkdir -pv ${LFS}/etc
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
   ${LFS}/etc/$FILE
   return
fi
cat > ${LFS}/etc/$FILE << "EOF"
# Begin /etc/fstab

# file system  mount-point  type     options             dump  fsck
#                                                              order
# Exemple de montage nfs
# 192.168.254.254:/home/thierry /home/thierry nfs rw,vers=3,_netdev,rsize=8192,wsize=8192 0 0
EOF
}
generate_bashrc() {
local FILE
FILE=".bashrc"
[ -f ${LFS}/etc/skel/$FILE ] && return
[ ! -d ${LFS}/etc/skel ] && mkdir -pv ${LFS}/etc/skel
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
   ${LFS}/etc/skel/$FILE
   return
fi
cat > ${LFS}/etc/skel/$FILE << "EOF"
# Personal aliases and functions.

# Personal environment variables and startup programs should go in
# ~/.bash_profile.  System wide environment variables and startup
# programs are in /etc/profile.  System wide aliases and functions are
# in /etc/bashrc.

if [ -f "/etc/bashrc" ] ; then
  source /etc/bashrc
fi
if [ $EUID -eq 0 ] ; then
        alias nu='setup-nutyx -cu'
        alias del='cards remove'
        alias get='cards install'
        alias up='cards install -u'
        alias check='cards diff'
        alias sysup='cards upgrade'
else
        alias nu='sudo setup-nutyx -cu'
        alias del='sudo cards remove'
        alias get='sudo cards install'
        alias up='sudo cards install -u'
        alias check='sudo cards diff'
        alias sysup='sudo cards upgrade'
fi
alias search='cards search'
alias ll='ls -l'
alias l='ls -alh'
alias duh='du -h --max-depth=1'
alias dfh='df -h'
alias pkgfind='cards list | grep -i'

# End ~/.bashrc
EOF
[ -f ${LFS}/root/$FILE ] && return
[ ! -d ${LFS}/root ] && install -dv -m0750 ${LFS}/root
cp -v ${LFS}/etc/skel/$FILE \
${LFS}/root
}
generate_bash_profile() {
local FILE
FILE=".bash_profile"
[ -f ${LFS}/etc/skel/$FILE ] && return
[ ! -d ${LFS}/etc/skel ] && mkdir -pv ${LFS}/etc/skel
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
   ${LFS}/etc/skel/$FILE
   return
fi
cat > ${LFS}/etc/skel/$FILE << "EOF"
# Personal environment variables and startup programs.

# Personal aliases and functions should go in ~/.bashrc.  System wide
# environment variables and startup programs are in /etc/profile.
# System wide aliases and functions are in /etc/bashrc.

append () {
  # First remove the directory
  local IFS=':'
  local NEWPATH
  for DIR in $PATH; do
     if [ "$DIR" != "$1" ]; then
       NEWPATH=${NEWPATH:+$NEWPATH:}$DIR
     fi
  done
  # Then append the directory
  export PATH=$NEWPATH:$1
}

if [ -f "$HOME/.bashrc" ] ; then
  source $HOME/.bashrc
fi

# unset append

# End ~/.bash_profile
EOF
[ ! -d ${LFS}/root ] && install -dv -m0750 ${LFS}/root
[ -f ${LFS}/root/$FILE ] && return
cp -v ${LFS}/etc/skel/$FILE \
${LFS}/root
}
generate_pkgmk_conf() {
local FILE
FILE="pkgmk.conf"
[ -f ${LFS}/etc/$FILE ] && return
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
  [ ! -d ${LFS}/etc ] && mkdir -pv ${LFS}/etc
  cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
  ${LFS}/etc/$FILE
fi
}
generate_cards_conf() {
local FILE
FILE="cards.conf"
[ -f ${LFS}/etc/$FILE ] && return
[ ! -d ${LFS}/etc ] && mkdir -pv ${LFS}/etc
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
   ${LFS}/etc/$FILE
   return
fi

echo "
# Default server URL
url ${URL}
#
## For all the graphical applications and desktops
dir ${DEPOT}/gui-extra
#
## For a minimal graphical interface
dir ${DEPOT}/gui
#
## For all the console applications
dir ${DEPOT}/cli-extra
#
## For a minimal console interface
dir ${DEPOT}/cli
#
## Chroot system without reboot possibilities for a chroot
dir ${DEPOT}/base
#
## Normaly you want to keep base and
base ${DEPOT}/base
#
#
## If you want to keep more collections remove comments below
# Adjust to your needs
#
# base ${DEPOT}/cli
# base ${DEPOT}/cli-extra
# base ${DEPOT}/gui
# base ${DEPOT}/gui-extra
# base ${DEPOT}/..." >> ${LFS}/etc/cards.conf
}
generate_nutyx_version() {
local FILE
FILE="nutyx-version"
[ -f ${LFS}/var/lib/pkg/$FILE ] && return
[ ! -d ${LFS}/var/lib/pkg ] && mkdir -pv ${LFS}/var/lib/pkg
echo "name ${CODE_NAME}
version $VERSION" > ${LFS}/var/lib/pkg/$FILE
}
generate_lsb() {
echo "DISTRIB_ID=\"NuTyX\"
DISTRIB_DESCRIPTION=\"NuTyX GNU/Linux\"
DISTRIB_CODENAME=\"${CODE_NAME}\"
DISTRIB_RELEASE=\"$VERSION\"
LSB_VERSION=\"1.4-1\"" > ${LFS}/etc/lsb-release
}
install_resolv_conf() {
[ -f /etc/resolv.conf ] && cp /etc/resolv.conf ${LFS}/etc
}
successfull_installation () {
echo "
****************************************************
      Installation of NuTyX $VERSION installed
      in $LFS sucessfully
****************************************************

****************************************************
* Thanks for installing NuTyX. Make sure to review *
*                                                  *
*       http://www.nutyx.org/en/install-nutyx      *
*                                                  *
*    Check your /etc/cards.conf file so that       *
*         it's fits your requirements              *
*                                                  *
****************************************************
"
}
check_tools() {
local FILE
[ ! -f "$(which curl)" ] && error "You need to install 'curl'"
[ ! -f "$(which bsdtar)" ] && error "You need to install 'libarchive'"
[ -z $ISO ] && return

[ ! -f "$(which xorriso)" ] && error "You need to install 'libisoburn'"
[ ! -f "$(which isohybrid)" ] && error "You need to install 'syslinux'"
[ ! -f "$(which mkdosfs)" ] && error "You need to install 'dosfstools'"
for FILE in libutil.c32 libcom32.c32 ldlinux.c32 vesamenu.c32 isolinux.bin
do
	[ ! -f /usr/lib/syslinux/$FILE ] && \
		error "syslinux not properly installed"
done

}
check_root() {
if [ "$UID" -ne 0 ]; then
	echo "
You are not root, cannot continue...
"
	exit 1
fi
}
check_variables() {

CR="nutyx busybox curl gcc bzip2 glibc \
zlib lz4 xz zstd libarchive openssl cards"

if [ -z "$CHROOT" ]; then
	CHROOT="$CR"
else
	CHROOT="$CR $CHROOT"
fi

[ "$ARCH" = "i686" -a "$HOST_ARCH" = "x86_64" ] && \
	CHROOT="$CR util-linux"
unset CR

[ -z "$URL" ] && URL="http://downloads.nutyx.org"

[ -z "$MOUNT" ] || VERSION="$(basename $MOUNT)"

[ -z "$VERSION" ] && VERSION="rolling"
if [ "$VERSION" == "development" ]; then
	CODE_NAME="$(date +%Y%m%d)"
else
	CODE_NAME="Houaphan"
fi

[ -z "$DEPOT" ] && DEPOT="/var/lib/pkg/depot"
[ -z "$LFS" ] && LFS="/mnt/hd"

[ -z "$STRICT" ] && STRICT="kernel"
[ -z "$MINI" ] && MINI="dhcpcd"
[ -z "$BASE" ] && BASE="efibootmgr linux-firmware systemd runyx \
wireless-tools wpa-supplicant"
[ -z "$CLI" ] && CLI="gpm gpm.service dosfstools make-ca xdg-user-dirs \
sound-theme-freedesktop ntp ntp.service"
[ -z "$GUI" ] && GUI="flcards gvfs network-manager-applet"
[ -z "$XORG" ] && XORG="xorg-xinit xorg-xf86-input-synaptics \
xorg-xf86-input-wacom xorg-xf86-video-ati \
xorg-xf86-video-fbdev xorg-xf86-video-intel \
xorg-xf86-video-nouveau xorg-xf86-video-vesa \
xorg-xrandr xorg-setxkbmap"

[ -z "$GUI_EXTRA" ] && GUI_EXTRA="firefox thunderbird gparted leafpad \
scrot vlc telegram"
[ -z "$KDE5_EXTRA" ] && KDE5_EXTRA="kdenlive k3b"
[ -z "$GNOME_EXTRA" ] && GNOME_EXTRA="epiphany seahorse-nautilus evolution \
simple-scan gnome-weather gnome-chess balsa"

[ -z "$OPENBOX" ] && OPENBOX="lxdm openbox dmenu"
[ -z "$JWM" ] && JWM="lxdm jwm"
[ -z "$LXDE" ] && LXDE="lxdm lxde"
[ -z "$XFCE4" ] && XFCE4="lxdm xfce4 xfce4-extra"
[ -z "$MATE" ] && MATE="lightdm mate"
[ -z "$GNOME" ] && GNOME="gnome"
[ -z "$KDE5" ] && KDE5="kde5"

[ "$KERNEL" = "NONE" ] && KERNEL="none"

if [ "$KERNEL" != "none"  ]; then
	CORE="acl attr bash coreutils readline \
expat ncurses lzo gmp flex file gzip mpc mpfr \
grep sed findutils binutils \
inetutils diffutils shadow \
bc less libcap util-linux \
kmod kbd pam \
gdbm e2fsprogs libpipeline \
gettext procps-ng \
psmisc sudo tzdata \
iproute2 iana-etc \
groff man-db \
cards.man nutyx.man \
dialog cpio squashfs \
lsb-release grub eudev \
sysklogd sysvinit $KERNEL "
fi

if [ ! -z $ISO ]; then
	ISO=${ISO^^}
	case ${ISO} in
		STRICT) CORE+="$STRICT";;
		MINI) CORE+="$STRICT $MINI";;
		BASE) CORE+="$STRICT $BASE";;
		CLI) CORE+="$STRICT $BASE $CLI";;
		GUI) CORE+="STRICT $BASE $CLI $GUI";;
		XORG) CORE+="$STRICT $BASE $CLI $GUI $XORG";;
		GUI_EXTRA) CORE+="$STRICT $BASE $CLI $GUI $XORG ${GUI_EXTRA}";;
		OPENBOX) CORE+="$STRICT $BASE $CLI $GUI ${GUI_EXTRA} $XORG $OPENBOX";;
		JWM) CORE+="$STRICT $BASE $CLI $GUI $XORG ${GUI_EXTRA} $JWM";;
		LXDE) CORE+="$STRICT $BASE $CLI $GUI $XORG ${GUI_EXTRA} $LXDE";;
		XFCE4) CORE+="$STRICT $BASE $CLI $GUI $XORG ${GUI_EXTRA} $XFCE4";;
		MATE) CORE+="$STRICT $BASE $CLI $GUI $XORG ${GUI_EXTRA} $MATE";;
		GNOME) CORE+="$STRICT $BASE $CLI $GUI $XORG $GUI_EXTRA $GNOME ${GNOME_EXTRA}";;
		KDE5) CORE+="$STRICT $BASE $CLI $GUI $XORG $GUI_EXTRA $KDE5 $KDE5_EXTRA";;
		*) echo "Valid ISO names: strict, mini, base, cli, gui, xorg, \
gui_extra, openbox, jwm, lxde, xfce4, mate, gnome, kde5" && exit 1;;
	esac
fi
if [ ! -z "$ISO" ];then
	DEVEL+="
for k in \$(ls /lib/modules/)
do
  mkinitramfs \$k -nf
done
sed -i \"s@kernel-419@\$KERNEL@g\" /sbin/setup-nutyx"
	if [ -z $MOUNT ]; then
		DEVEL+="
cards purge"
	else
		DEVEL+="
umount $DEPOT"
	fi
	DEVEL+="
for d in opt bin etc lib lib64 root run sbin usr var home
do
  rm -f /ISO/boot/\$d.squashfs
  mksquashfs /\$d /ISO/boot/\$d.squashfs
done
exit 0"
fi

HOMEPAGE="${URL}"                           ## http://downloads.nutyx.org
INSTALL_BASE="$ARCH/$VERSION"               ## x86_64/rolling
DEPOT_ROOT="$HOMEPAGE/${INSTALL_BASE}"      ## http://downloads.nutyx.org/x86_64/rolling
DEPOT_BASE="$DEPOT_ROOT/${BASE_COLLECTION}" ## http://downloads.nutyx.org/x86_64/rolling/base

LOCAL_DEPOT_PACKAGES="$DEPOT/${BASE_COLLECTION}"
DEPOT_CD="/media/cdrom"

SETUP_FILE="/tmp/setup"
}
config() {
[ -f /etc/$(basename $INSTALL_COMMAND).conf ] && \
		source /etc/$(basename $INSTALL_COMMAND).conf

HOST_ARCH=$(uname -m)
[ -z "$ARCH" ] && ARCH=$(uname -m)
[ "$ARCH" = "i686" -a "$HOST_ARCH" = "x86_64" ] && LINUX_ARCH="linux32" \
	|| LINUX_ARCH=""

# Number of seconds between STOPSIG and FALLBACK when stopping processes
KILLDELAY="3"

## Screen Dimensions
# Find current screen size

if [ -z "${COLUMNS}" ]; then
        COLUMNS=$(stty size)
        COLUMNS=${COLUMNS##* }
fi

# When using remote connections, such as a serial port, stty size returns 0
if [ "${COLUMNS}" = "0" ]; then
        COLUMNS=80
fi

## Measurements for positioning result messages
COL=$((${COLUMNS} - 8))
WCOL=$((${COL} - 2))

## Provide an echo that supports -e and -n
# If formatting is needed, $ECHO should be used
case "$(echo -e -n test)" in
        -[en]*)
                ECHO=$(which echo)
                ;;
        *)
                ECHO=echo
                ;;
esac

## Set Cursor Position Commands, used via $ECHO
SET_COL="\\033[${COL}G"      # at the $COL char
SET_WCOL="\\033[${WCOL}G"    # at the $WCOL char
CURS_UP="\\033[1A\\033[0G"   # Up one line, at the 0'th char

## Set color commands, used via $ECHO
# Please consult `man console_codes for more information
# under the "ECMA-48 Set Graphics Rendition" section
#
# Warning: when switching from a 8bit to a 9bit font,
# the linux console will reinterpret the bold (1;) to
# the top 256 glyphs of the 9bit font.  This does
# not affect framebuffer consoles
NORMAL="\\033[0;39m"         # Standard console grey
SUCCESS="\\033[1;32m"        # Success is green
WARNING="\\033[1;33m"        # Warnings are yellow
FAILURE="\\033[1;31m"        # Failures are red
INFO="\\033[1;36m"           # Information is light cyan
BRACKET="\\033[1;34m"        # Brackets are blue

STRING_LENGTH="0"   # the length of the current message
}
mount_depot() {
if [ ! -z $MOUNT ]; then
	mkdir -p $LFS/$DEPOT
	mount --bind $MOUNT  $LFS/$DEPOT \
		|| error "cannot mount $MOUNT on $LFS/$DEPOT"
fi
}
check_arch() {
if [ "$ARCH" != "x86_64" ] && [ "$ARCH" != "i686" ] \
	&& [ "$ARCH" != "aarch64" ]; then
	boot_mesg "
 >>> This arch ($ARCH) is not supported"
	echo_failure
	exit 1
fi
}

create_locale_link() {
[ ! -d ${LFS}/etc/locale ] && mkdir -p ${LFS}/etc/locale
if [ -d ${LFS}/usr/lib/locale ]; then
   rm -r ${LFS}/usr/lib/locale
   ln -sv /etc/locale/ ${LFS}/usr/lib/locale
fi
}
make_directories() {
mkdir -p ${LFS}/{dev,sys,proc,run,tmp,srv,mnt}
mkdir -p ${LFS}/var/tmp
mkdir -p ${LFS}/usr/{,local/}lib

chmod 1777 ${LFS}/{,var/}tmp

mkdir -p ${LFS}/var/{mail,spool}
mkdir -p ${LFS}/var/run/lock

mknod -m 600 ${LFS}/dev/console c 5 1
mknod -m 666 ${LFS}/dev/null c 1 3
if [ ! -z "$ISO" ]; then
	mkdir -p ${LFS}/ISO/{boot,iso,isolinux}
	cat > $TMP/install.cfg << "EOF"
default install
label install
 menu label ^Install
 kernel /boot/kernel-#VERSION_KERNEL#
 append initrd=/boot/initrd-#VERSION_KERNEL# vga=788 ro quiet

label install-debug
 menu label install-^Debug
 kernel /boot/kernel-#VERSION_KERNEL#
 append initrd=/boot/initrd-#VERSION_KERNEL#  vga=788 ro testiso

label install-toram
 menu label Install copied to ^RAM
 kernel /boot/kernel-#VERSION_KERNEL#
 append initrd=/boot/initrd-#VERSION_KERNEL# vga=788 ro quiet toram

label install-debug-toram
 menu label install-Debug copied to RA^M
 kernel /boot/kernel-#VERSION_KERNEL#
 append initrd=/boot/initrd-#VERSION_KERNEL#  vga=788 ro testiso toram
fi

EOF
	cat > ${LFS}/ISO/isolinux/isolinux.cfg << "EOF"
path
include menu.cfg
default vesamenu.c32
prompt 0
timeout 100

EOF
	cat > $TMP/live.cfg << "EOF"
label live
 menu label ^Live
 kernel /boot/kernel-#VERSION_KERNEL#
 append initrd=/boot/initrd-#VERSION_KERNEL# vga=788 ro quiet live

label live-debug
 menu label li^ve-Debug
 kernel /boot/kernel-#VERSION_KERNEL#
 append initrd=/boot/initrd-#VERSION_KERNEL# vga=788 ro testiso live

label live-toram
 menu label live copied to ^RAM
 kernel /boot/kernel-#VERSION_KERNEL#
 append initrd=/boot/initrd-#VERSION_KERNEL# vga=788 ro quiet live toram

label live-debug-toram
 menu label live-Debug copied to ^RAM
 kernel /boot/kernel-#VERSION_KERNEL#
 append initrd=/boot/initrd-#VERSION_KERNEL# vga=788 ro testiso live toram

EOF
	cat > $TMP/menu.cfg << "EOF"
menu hshift 7
menu width 80

menu title NuTyX GNU/Linux installer #VERSION_NUTYX# #VERSION_KERNEL#
include stdmenu.cfg
include install.cfg
include live.cfg

menu end

EOF
cat > ${LFS}/ISO/isolinux/stdmenu.cfg << "EOF"
menu background ../boot/grub/splash.png
menu color title	* #FFFFFFFF *
menu color border	* #00000000 #00000000 none
menu color sel		* #ffffffff #76a1d0ff *
menu color hotsel	1;7;37;40 #ffffffff #76a1d0ff *
menu color tabmsg	* #ffffffff #00000000 *
menu color help		37;40 #ffdddd00 #00000000 none
# XXX When adjusting vshift, take care that rows is set to a small
# enough value so any possible menu will fit on the screen,
# rather than falling off the bottom.
menu vshift 8
menu rows 12
# The help line must be at least one line from the bottom.
menu helpmsgrow 14
# The command line must be at least one line from the help line.
menu cmdlinerow 16
menu timeoutrow 16
menu tabmsgrow 18
menu tabmsg Press ENTER to boot or TAB to edit a menu entry

EOF
fi
}
download_pkgadd() {
	PKGADD="$(which pkgadd)"
	if [ "$PKGADD" != "" ];then
		mkdir -p $TMP/$(dirname $PKGADD)
		cp  $PKGADD $TMP/$(dirname $PKGADD)/
		ln -s $TMP/$(dirname $PKGADD)/pkgadd  $TMP/$(dirname $PKGADD)/pkginfo
	else
		PKGADD="/bin/pkgadd"

		getPackageFileName cards

		if [ ! -f $TMP/$PKGADD ]; then
			cd $TMP
			PackageFileName=""
			getPackageFileName cards
			if [ "$PackageFileName" == "" ]; then
				error "variable 'PackageFileName' is not set"
			fi
			download_pkg cards
			echo "Extraction of cards ..."
			bsdtar -xf $LFS/$DEPOT/${BASE_COLLECTION}/cards/${PackageFileName} \
				|| print_error_msg
			echo_ok
		fi
	fi
}
generate_setupfile() {
if [ "$SHELL" == "/bin/bash" ]; then
  SHELL=/bin/ash
  if [ -f $LFS/bin/bash ]; then
	SHELL=/bin/bash
  fi
fi
if [[ -z "$CORE" && -z "$DEVEL" ]];then
	echo "exit" > $LFS/$SETUP_FILE
else
	echo "source /etc/profile" \
	 > $LFS/$SETUP_FILE
	[ -z $MOUNT ] && echo "cards sync" >> \
	$LFS/$SETUP_FILE
	echo "cards install -n $CORE $DEVEL
exit" >> $LFS/$SETUP_FILE
fi
chmod 177 $LFS/$SETUP_FILE
setup_chroot
chroot ${LFS} env -i \
HOME=/root \
EUID=0 \
TERM="$TERM"  \
KERNEL="$KERNEL" \
PS1='\u:\w\$ ' \
$LINUX_ARCH \
"$SHELL" -c "$SETUP_FILE"
unmountall
}
install_configuration_files() {
	generate_cards_conf
	generate_pkgmk_conf
	generate_fstab
	generate_passwd
	generate_group
	generate_bash_profile
	generate_bashrc
	generate_hosts
	generate_inputrc
	generate_shells
	generate_dircolors_sh
	generate_extrapaths_sh
	generate_readline_sh
	generate_umask_sh
	generate_profile
	generate_inputrc
	generate_modules
	generate_createfiles
	generate_mouse
	generate_udev_retry
	generate_rc_site
	generate_etc_bashrc
	generate_lsb
	generate_nutyx_version
}
show_variables() {
echo "
List of variables: 

LFS        : $LFS
URL        : $URL
VERSION    : $VERSION
KERNEL     : $KERNEL
DEPOT      : $DEPOT
MOUNT      : $MOUNT
SHELL      : $SHELL
DEPOT_BASE : $DEPOT_BASE
CHROOT     : $CHROOT
CORE       : $CORE
DEVEL      : $DEVEL
ISO        : $ISO"
[ -z "$ISO" ] || echo "STRICT     : $STRICT
MINI       : $MINI
BASE       : $BASE
CLI        : $CLI
GUI        : $GUI
GUI_EXTRA  : $GUI_EXTRA
XORG       : $XORG
GNOME_EXTRA: ${GNOME_EXTRA}
KDE5_EXTRA : ${KDE5_EXTRA}
JWM        : $JWM
LXDE       : $LXDE
XFCE4      : $XFCE4
MATE       : $MATE
GNOME      : $GNOME
KDE5       : $KDE5
ISO Filename $LFS/NuTyX_${ARCH}-$VERSION_NUTYX-$ISO.iso"
}
print_help() {
	echo "
usage: `basename ${INSTALL_COMMAND}` [options]
options

  -ec,  --enter-chroot    will enter in the chroot if exist
  -ic,  --install-config  will install all the configuration files only
   -t,  --test            print all the variables and exit
   -h,  --help            print help and exit
   -v,  --version         print the version and exit
"

}

parse_options() {
	while [ "$1" ]; do
		case $1 in
			-h|--help)
				print_help
				exit 0;;
			-t|--test)
				show_variables
				exit 0;;
			-ec|--enter-chroot)
				check_root
				setup_chroot
				mount_depot
				enter_chroot
				unmountall
				exit 0;;
			-ic|--install-config)
				check_root
				mkdir -p $LFS
				make_directories
				create_locale_link
				install_configuration_files
				exit 0;;
			-v|--version)
				echo "$(basename $INSTALL_COMMAND) $VERSION_NUTYX-$RELEASE"
				exit 0;;
			/*)
				boot_mesg "
 >>> Do not use arguments anymore ...
"
				exit 1;;
			*)
				echo "$(basename $0): invalid option $1"
				exit 1 ;;
		esac
		shift
	done
}
generate_iso() {
local FILE MD5SUM VERSION_KERNEL LABEL GRUB_EFI_ARCH GRUB_EFI_IMG ISODIR \
SCRIPTDIR

LABEL="nutyxcd"
GRUB_EFI_ARCH="x86_64"
GRUB_EFI_IMG="bootx64.efi"
ISODIR=$LFS/ISO
SCRIPTDIR=$(pwd -P)

VERSION_KERNEL="$(basename $LFS/lib/modules/*-NuTyX)"
ISO="NuTyX_${ARCH}-$VERSION_NUTYX-$ISO"
cd ${ISODIR} || error "cd ${ISODIR}"

for FILE in libutil.c32 libcom32.c32 ldlinux.c32 vesamenu.c32 isolinux.bin
do
	cp /usr/lib/syslinux/$FILE isolinux/
done

sed "s|#VERSION_NUTYX#|${VERSION_NUTYX}-$ISO|" \
	$TMP/menu.cfg \
	> isolinux/menu.cfg
sed "s|#VERSION_KERNEL#|${VERSION_KERNEL}|" \
	$TMP/live.cfg \
	> isolinux/live.cfg
sed "s|#VERSION_KERNEL#|${VERSION_KERNEL}|" \
	$TMP/install.cfg \
	> isolinux/install.cfg
sed -i "s|#VERSION_KERNEL#|${VERSION_KERNEL}|" isolinux/menu.cfg

# efi stufs
rm -rf iso
rm -rf boot/grub
mkdir -p {iso/EFI,boot/grub/{fonts,${GRUB_EFI_ARCH}-efi}}

# grub
[ -f /usr/share/grub/unicode.pf2 ] && \
	cp /usr/share/grub/unicode.pf2 boot/grub/fonts

[ -f /usr/share/grub/splash.png ] && \
	cp /usr/share/grub/splash.png boot/grub/splash.png

echo "set prefix=/boot/grub" > iso/grub-early.cfg

cp -a /usr/lib/grub/${GRUB_EFI_ARCH}-efi/*.mod \
	/usr/lib/grub/${GRUB_EFI_ARCH}-efi/*.lst \
	boot/grub/${GRUB_EFI_ARCH}-efi

cat  > boot/grub/grub.cfg << "EOF"
set default=0
set timeout=99

# set debug=all
# set pager=1

insmod all_video
if loadfont /boot/grub/fonts/unicode.pf2; then
  set gfxmode=800x600
  insmod efi_gop
  insmod efi_uga
  insmod video_bochs
  insmod video_cirrus
  insmod gfxterm
  insmod png
  terminal_output gfxterm
fi

if background_image /boot/grub/splash.png; then
  set color_normal=light-gray/black
  set color_highlight=white/black
else
  set color_normal=cyan/blue
  set color_highlight=white/blue
fi

menuentry "NuTyX #ARCH# #VERSION_NUTYX# #VERSION_KERNEL# (UEFI mode) normal" {

    linux /boot/kernel-#VERSION_KERNEL#  ro quiet
    initrd /boot/initrd-#VERSION_KERNEL#
}
menuentry "NuTyX #ARCH# #VERSION_NUTYX# #VERSION_KERNEL# (UEFI mode) debug" {
    set background_color=black
    linux /boot/kernel-#VERSION_KERNEL#  ro testiso rootdelay=3
    initrd /boot/initrd-#VERSION_KERNEL#
}
menuentry "NuTyX #ARCH# #VERSION_NUTYX# #VERSION_KERNEL# (UEFI mode) copied to RAM" {

    linux /boot/kernel-#VERSION_KERNEL#  ro quiet toram
    initrd /boot/initrd-#VERSION_KERNEL#
}
menuentry "NuTyX #ARCH# #VERSION_NUTYX# #VERSION_KERNEL# (UEFI mode) debug copied to RAM" {
    set background_color=black
    linux /boot/kernel-#VERSION_KERNEL#  ro testiso rootdelay=3 toram
    initrd /boot/initrd-#VERSION_KERNEL#
}
menuentry "NuTyX #ARCH# #VERSION_NUTYX# #VERSION_KERNEL# (UEFI mode) installable live" {
    linux /boot/kernel-#VERSION_KERNEL#  ro quiet rootdelay=5 live
    initrd /boot/initrd-#VERSION_KERNEL#
}
menuentry "NuTyX #ARCH# #VERSION_NUTYX# #VERSION_KERNEL# (UEFI mode) debug live" {
    linux /boot/kernel-#VERSION_KERNEL#  ro testiso rootdelay=3 live
    initrd /boot/initrd-#VERSION_KERNEL#
}
menuentry "NuTyX #ARCH# #VERSION_NUTYX# #VERSION_KERNEL# (UEFI mode) installable live copied to RAM" {
    linux /boot/kernel-#VERSION_KERNEL#  ro quiet rootdelay=5 live toram
    initrd /boot/initrd-#VERSION_KERNEL#
}
menuentry "NuTyX #ARCH# #VERSION_NUTYX# #VERSION_KERNEL# (UEFI mode) debug live copied to RAM" {
    linux /boot/kernel-#VERSION_KERNEL#  ro testiso rootdelay=3 live toram
    initrd /boot/initrd-#VERSION_KERNEL#
}
EOF
sed -i "s|#VERSION_NUTYX#|${VERSION_NUTYX}-$ISO|" boot/grub/grub.cfg
sed -i "s|#VERSION_KERNEL#|${VERSION_KERNEL}|" boot/grub/grub.cfg
sed -i "s|#ARCH#|${ARCH}|" boot/grub/grub.cfg

for FILE in kernel initrd
do
	[ -f isolinux/$FILE ] && mv -v isolinux/$FILE boot/
done

grub-mkimage -c iso/grub-early.cfg -o iso/EFI/${GRUB_EFI_IMG} \
	-O ${GRUB_EFI_ARCH}-efi -p "" iso9660 normal \
	search search_fs_file || error "grub-mkimage"

# efiboot.img
modprobe loop

dd if=/dev/zero of=iso/efiboot.img count=4096

mkdosfs -n "${LABEL}" iso/efiboot.img || error "mkdosfs"
mkdir -p iso/efiboot
mount -o loop iso/efiboot.img iso/efiboot || error "mount efiboot.img"
mkdir -p iso/efiboot/EFI/boot
cp       iso/EFI/${GRUB_EFI_IMG} iso/efiboot/EFI/boot

umount iso/efiboot

# Iso generation

xorriso -as mkisofs -R -l -J -o ${LFS}/${ISO}.iso \
-A NUTYX \
-b isolinux/isolinux.bin \
-c isolinux/boot.cat -no-emul-boot -boot-load-size 4 \
-boot-info-table \
-eltorito-alt-boot -e iso/efiboot.img -no-emul-boot \
-input-charset utf-8 -V "${LABEL}" .

cd ${LFS}
isohybrid -u ${ISO}.iso || error "isohybrid ${ISO}.iso"
sha256sum ${ISO}.iso > ${ISO}.sha256sum
}
main() {
	config
	check_variables  "$@"
	check_arch
	parse_options "$@"
	mount_depot
	show_variables
	check_root

	TMP=$(mktemp -d)
	check_tools
	mkdir -p $LFS

	download_pkgadd
	mkdir -p ${LFS}/var/lib/pkg/DB
	install_chroot

	create_locale_link
	make_directories
	install_configuration_files
	install_resolv_conf
	generate_setupfile
	[ -z "$ISO" ] || generate_iso
	successfull_installation
	end

}
readonly BASE_COLLECTION=base
readonly VERSION_NUTYX=#VERSION#
readonly RELEASE=1
INSTALL_COMMAND="$(basename $0)"
main "$@"
